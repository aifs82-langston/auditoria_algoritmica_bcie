# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hV9PphoT7_jyRzsiTkOJP_vu7wuolnWX
"""

import streamlit as st
import pandas as pd
import numpy as np
import requests
import matplotlib.pyplot as plt
import seaborn as sns
from sentence_transformers import SentenceTransformer
from sklearn.cluster import KMeans
from sklearn.decomposition import PCA
from sklearn.feature_extraction.text import TfidfVectorizer
import textwrap
import io
import os

# ==========================================
# 1. CONFIGURACI√ìN DE LA P√ÅGINA Y ESTILO
# ==========================================
st.set_page_config(
    page_title="Auditor√≠a algor√≠tmica de los desemboldos del BCIE para los pa√≠ses fundadores",
    page_icon="üè¶",
    layout="wide"
)

# Estilo de gr√°ficos
sns.set(style="whitegrid", context="talk")

st.title("üè¶ Auditor√≠a Algor√≠tmica de los desembolsos del BCIE para los pa√≠ses fundadores")
st.markdown("""
**Auditor√≠a Algor√≠tmica de Datos Abiertos:**
Esta aplicaci√≥n conecta en tiempo real a las APIs del BCIE y del SDG Index, aplicando t√©cnicas de vectorizaci√≥n sem√°ntica (S-BERT), miner√≠a de texto y aprendizaje no supervisado para auditar la estructura funcional y financiera de la cartera de proyectos.
""")

# ==========================================
# 2. FUNCIONES DE CARGA (CON CACH√â)
# ==========================================

@st.cache_resource
def cargar_modelo_sbert():
    """Carga el modelo S-BERT en memoria (solo una vez)."""
    return SentenceTransformer('paraphrase-multilingual-MiniLM-L12-v2')

@st.cache_data(ttl=3600) # Cach√© por 1 hora
def descargar_datos_bcie():
    """Descarga, limpia y preprocesa los datos de la API del BCIE."""
    base_url = "https://datosabiertos.bcie.org/api/3/action/datastore_search"
    resource_id = "8794659a-285b-4f0d-b5a4-a704bdf823fb"
    params = {'resource_id': resource_id, 'limit': 50000}

    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
        data_json = response.json()

        if data_json['success']:
            df = pd.DataFrame(data_json['result']['records'])

            # Normalizaci√≥n
            df.columns = df.columns.str.upper().str.strip()

            # Tipos de datos
            if 'ANIO_DESEMBOLSO' in df.columns:
                df['ANIO_DESEMBOLSO'] = pd.to_numeric(df['ANIO_DESEMBOLSO'], errors='coerce')

            # Filtro Pa√≠ses y A√±os
            target_countries = ['GUATEMALA', 'EL SALVADOR', 'HONDURAS', 'NICARAGUA', 'COSTA RICA']
            if 'PAIS' in df.columns and 'ANIO_DESEMBOLSO' in df.columns:
                df['PAIS'] = df['PAIS'].str.upper().str.strip()
                df_filtered = df[
                    (df['PAIS'].isin(target_countries)) &
                    (df['ANIO_DESEMBOLSO'] >= 2010) &
                    (df['ANIO_DESEMBOLSO'] <= 2024)
                ].copy()

                # Limpieza de texto
                df_filtered['DESCRIPCION_PROYECTO'] = df_filtered['DESCRIPCION_PROYECTO'].fillna('').astype(str)
                df_filtered = df_filtered[df_filtered['DESCRIPCION_PROYECTO'].str.len() > 5]

                return df_filtered
            else:
                return None
        else:
            return None
    except Exception as e:
        st.error(f"Error conectando a API BCIE: {e}")
        return None

@st.cache_data(ttl=3600)
def cargar_datos_sdg():
    """Descarga los datos del SDG Index 2025 desde ArcGIS."""
    url = "https://services7.arcgis.com/IyvyFk20mB7Wpc95/arcgis/rest/services/Sustainable_Development_Report_2025_(with_indicators)/FeatureServer/0/query?where=1%3D1&outFields=*&outSR=4326&f=json"
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()

        if 'features' in data:
            rows = [feat['attributes'] for feat in data['features']]
            df = pd.DataFrame(rows)
            return df
        return pd.DataFrame()
    except Exception as e:
        st.error(f"Error conectando a API SDG: {e}")
        return pd.DataFrame()

def extraer_palabras_clave(texts, n=5):
    """Extrae caracter√≠sticas clave usando TF-IDF."""
    tfidf = TfidfVectorizer(stop_words=['de', 'la', 'el', 'en', 'y', 'los', 'del', 'para', 'las', 'un', 'con', 'por', 'proyecto', 'programa'],
                            ngram_range=(2, 3))
    try:
        matrix = tfidf.fit_transform(texts)
        feature_names = np.array(tfidf.get_feature_names_out())
        tfidf_mean = matrix.mean(axis=0).A1
        top_indices = tfidf_mean.argsort()[::-1][:n]
        return feature_names[top_indices]
    except ValueError:
        return ["Datos insuficientes"]

# ==========================================
# 3. L√ìGICA DE EJECUCI√ìN
# ==========================================

# Bot√≥n principal para iniciar todo el proceso
if st.button('üöÄ EJECUTAR AUDITOR√çA COMPLETA', type="primary"):

    # --- PASO 1: INGESTA BCIE ---
    with st.status("üì° Conectando a fuentes de datos...", expanded=True) as status:
        st.write("Descargando registros del BCIE...")
        df_bcie = descargar_datos_bcie()

        if df_bcie is not None and not df_bcie.empty:
            st.write(f"‚úÖ BCIE: {len(df_bcie)} registros procesados.")
        else:
            st.error("No se pudieron cargar los datos del BCIE.")
            st.stop()

        status.update(label="‚úÖ Datos descargados", state="complete", expanded=False)

    # --- PASO 2: MOTOR DE ALGORITMOS ---
    with st.spinner("üß† Ejecutando algoritmos (S-BERT + K-Means)..."):
        model = cargar_modelo_sbert()
        embeddings = model.encode(df_bcie['DESCRIPCION_PROYECTO'].tolist())

        # Clustering
        num_clusters = 3
        kmeans = KMeans(n_clusters=num_clusters, init='k-means++', random_state=42, n_init=10)
        df_bcie['Cluster_ID'] = kmeans.fit_predict(embeddings)

        # Feature Extraction
        feature_map = {}
        for k in range(num_clusters):
            subset = df_bcie[df_bcie['Cluster_ID'] == k]['DESCRIPCION_PROYECTO']
            top_features = extraer_palabras_clave(subset, n=5)
            feature_map[k] = ", ".join(top_features)

    # --- PREPARACI√ìN DE DATOS FINANCIEROS ---
    col_monto = 'MONTO_BRUTO_USD'
    if col_monto in df_bcie.columns:
        # Limpieza
        df_bcie[col_monto] = df_bcie[col_monto].astype(str).str.replace(r'[$,]', '', regex=True)
        df_bcie[col_monto] = pd.to_numeric(df_bcie[col_monto], errors='coerce').fillna(0)

        # Pivots
        pivot_monto = df_bcie.pivot_table(index='Cluster_ID', columns='PAIS', values=col_monto, aggfunc='sum').fillna(0)
        pivot_conteo = df_bcie.pivot_table(index='Cluster_ID', columns='PAIS', aggfunc='size').fillna(0)

        # Millones
        pivot_monto_millones = pivot_monto / 1_000_000

        # Valor promedio por operaci√≥n
        valor_promedio = pivot_monto_millones / pivot_conteo

        # Renombrar √≠ndices para visualizaci√≥n
        etiquetas_legibles = [f"C{i}\n({feature_map[i][:25]}...)" for i in pivot_monto.index]
        pivot_monto_millones.index = etiquetas_legibles
        valor_promedio.index = etiquetas_legibles

    # --- INTERFAZ DE RESULTADOS (TABS) ---
    st.success("‚úÖ Auditor√≠a finalizada. Resultados listos.")

    tab1, tab2, tab3, tab4 = st.tabs([
        "üåå Espacio Latente",
        "üí∞ Matriz Financiera",
        "üìè An√°lisis de Escala",
        "üåç Contexto ODS"
    ])

    # TAB 1: VISUALIZACI√ìN ESPACIO LATENTE
    with tab1:
        st.subheader("Figura 1. Auditor√≠a Algor√≠tmica: Espacio Latente de Operaciones en los pa√≠ses fundadores del BCIE")
        pca = PCA(n_components=2)
        coords = pca.fit_transform(embeddings)

        fig1, ax1 = plt.subplots(figsize=(10, 6))

        # Leyenda limpia
        etiquetas_plot = [f"C{k}: {feature_map[k][:30]}..." for k in df_bcie['Cluster_ID']]

        sns.scatterplot(
            x=coords[:, 0], y=coords[:, 1],
            hue=etiquetas_plot,
            style=df_bcie['PAIS'],
            palette='viridis', s=100, alpha=0.8, edgecolor='k', ax=ax1
        )
        ax1.set_xlabel("Dimensi√≥n Latente 1")
        ax1.set_ylabel("Dimensi√≥n Latente 2")
        ax1.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
        st.pyplot(fig1)

        st.info("üí° **Interpretaci√≥n:** Cada punto es un proyecto. La cercan√≠a indica similitud sem√°ntica. Los grupos revelan la estructura funcional oculta de la cartera.")

    # TAB 2: MATRIZ DE DESEMBOLSOS
    with tab2:
        st.subheader("Figura 2. Distribuci√≥n de Recursos por Cl√∫ster Sem√°ntico en los pa√≠ses fundadores del BCIE")
        fig2, ax2 = plt.subplots(figsize=(12, 6))

        # Heatmap Verde
        sns.heatmap(pivot_monto_millones, annot=True, fmt=".2f", cmap="Greens", linewidths=1, ax=ax2)
        ax2.set_ylabel("Cl√∫ster Sem√°ntico")
        st.pyplot(fig2)

        # Bot√≥n descarga
        buffer = io.BytesIO()
        with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
            df_bcie.to_excel(writer, sheet_name='Data_Cruda', index=False)
            pivot_monto_millones.to_excel(writer, sheet_name='Matriz_Montos')

        st.download_button(
            label="üíæ Descargar Resultados Financieros (Excel)",
            data=buffer,
            file_name="BCIE_Auditoria_Resultados.xlsx",
            mime="application/vnd.ms-excel"
        )

    # TAB 3: VALOR PROMEDIO POR OPERACI√ìN
    with tab3:
        st.subheader("Figura 3. An√°lisis de Escala: Valor Promedio por Operaci√≥n en los pa√≠ses fundadores del BCIE")
        fig3, ax3 = plt.subplots(figsize=(12, 6))

        # Heatmap Azul
        sns.heatmap(valor_promedio.fillna(0), annot=True, fmt=".2f", cmap="Blues", linewidths=1, ax=ax3)
        ax3.set_ylabel("Cl√∫ster Sem√°ntico")
        st.pyplot(fig3)

        st.markdown("""
        **Hallazgo Clave:** * **Azul Intenso:** Operaciones de gran escala (ej. Apoyo Presupuestario en Costa Rica).
        * **Azul Claro:** Capilaridad y cobertura territorial (ej. Infraestructura en Honduras/Nicaragua).
        """)

    # TAB 4: CONTEXTO ODS (ArcGIS)
    with tab4:
        st.subheader("Figura 4. Pa√≠ses fundadores del BCIE: √çndice de los ODS 2025")

        with st.spinner("Conectando a ArcGIS..."):
            df_sdg = cargar_datos_sdg()

            paises_bcie = ['Costa Rica', 'El Salvador', 'Guatemala', 'Honduras', 'Nicaragua']
            if not df_sdg.empty and 'Name' in df_sdg.columns:
                df_sdg_filt = df_sdg[df_sdg['Name'].isin(paises_bcie)].copy()
                df_sdg_filt = df_sdg_filt.sort_values('Overall_Score', ascending=True)

                fig4, ax4 = plt.subplots(figsize=(10, 6))
                bars = ax4.barh(df_sdg_filt['Name'], df_sdg_filt['Overall_Score'], color='#0055A4')

                ax4.set_xlabel('Puntaje General (Overall Score)')
                ax4.grid(axis='x', linestyle='--', alpha=0.5)
                ax4.set_xlim(0, 90)

                # Etiquetas en barras
                for bar in bars:
                    width = bar.get_width()
                    ax4.text(width + 0.5, bar.get_y() + bar.get_height()/2,
                             f'{width:.1f}', va='center', fontweight='bold')

                st.pyplot(fig4)
            else:
                st.warning("No se pudieron recuperar los datos del SDG Index en este momento.")

else:
    st.info("üëà Haz clic en el bot√≥n para iniciar la auditor√≠a en tiempo real.")
